import {
  require_js
} from "./chunk-KJCMRRI5.js";
import {
  __commonJS
} from "./chunk-MB5FDF5C.js";

// node_modules/is-whitespace/index.js
var require_is_whitespace = __commonJS({
  "node_modules/is-whitespace/index.js"(exports, module) {
    "use strict";
    var cache;
    module.exports = function isWhitespace(str) {
      return typeof str === "string" && regex().test(str);
    };
    function regex() {
      return cache || (cache = new RegExp('^[\\s	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF"]+$'));
    }
  }
});

// node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/is-extendable/index.js"(exports, module) {
    "use strict";
    module.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/extend-shallow/index.js"(exports, module) {
    "use strict";
    var isObject = require_is_extendable();
    module.exports = function extend(o) {
      if (!isObject(o)) {
        o = {};
      }
      var len = arguments.length;
      for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isObject(obj)) {
          assign(o, obj);
        }
      }
      return o;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports, module) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/condense-newlines/index.js
var require_condense_newlines = __commonJS({
  "node_modules/condense-newlines/index.js"(exports, module) {
    "use strict";
    var isWhitespace = require_is_whitespace();
    var extend = require_extend_shallow();
    var typeOf = require_kind_of();
    module.exports = function(str, options) {
      var opts = extend({}, options);
      var sep = opts.sep || "\n\n";
      var min = opts.min;
      var re;
      if (typeof min === "number" && min !== 2) {
        re = new RegExp("(\\r\\n|\\n|\\u2424) {" + min + ",}");
      }
      if (typeof re === "undefined") {
        re = opts.regex || /(\r\n|\n|\u2424){2,}/g;
      }
      if (opts.keepWhitespace !== true) {
        str = str.split("\n").map(function(line) {
          return isWhitespace(line) ? line.trim() : line;
        }).join("\n");
      }
      str = trailingNewline(str, opts);
      return str.replace(re, sep);
    };
    function trailingNewline(str, options) {
      var val = options.trailingNewline;
      if (val === false) {
        return str;
      }
      switch (typeOf(val)) {
        case "string":
          str = str.replace(/\s+$/, options.trailingNewline);
          break;
        case "function":
          str = options.trailingNewline(str);
          break;
        case "undefined":
        case "boolean":
        default: {
          str = str.replace(/\s+$/, "\n");
          break;
        }
      }
      return str;
    }
  }
});

// node_modules/pretty/index.js
var require_pretty = __commonJS({
  "node_modules/pretty/index.js"(exports, module) {
    var beautify = require_js();
    var condense = require_condense_newlines();
    var extend = require_extend_shallow();
    var defaults = {
      unformatted: ["code", "pre", "em", "strong", "span"],
      indent_inner_html: true,
      indent_char: " ",
      indent_size: 2,
      sep: "\n"
    };
    module.exports = function pretty(str, options) {
      var opts = extend({}, defaults, options);
      str = beautify.html(str, opts);
      if (opts.ocd === true) {
        if (opts.newlines)
          opts.sep = opts.newlines;
        return ocd(str, opts);
      }
      return str;
    };
    function ocd(str, options) {
      return condense(str, options).replace(/^\s+/g, "").replace(/\s+$/g, "\n").replace(/(\s*<!--)/g, "\n$1").replace(/>(\s*)(?=<!--\s*\/)/g, "> ");
    }
  }
});
export default require_pretty();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * condense-newlines <https://github.com/jonschlinkert/condense-newlines>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-whitespace <https://github.com/jonschlinkert/is-whitespace>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * pretty <https://github.com/jonschlinkert/pretty>
 *
 * Copyright (c) 2013-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=pretty.js.map
